(S (NP (NNP Applicative) (NNS functors)) (VP (VBP are) (NP (NP (DT a) (NN generalisation)) (PP (IN of) (NP (NNS monads))))) (. .))
(S (NP (DT Both)) (VP (VBP allow) (NP (NP (DT the) (NN expression)) (PP (IN of) (NP (JJ effectful) (NNS computations)))) (PP (IN into) (NP (NP (DT an) (ADJP (RB otherwise) (JJ pure)) (NN language)) (, ,) (PP (IN like) (NP (NNP Haskell)))))) (. .))
(S (NP (NNP Applicative) (NNS functors)) (VP (VBP are) (S (VP (TO to) (VP (VB be) (VP (VBN preferred) (PP (IN to) (NP (NP (NNS monads)) (SBAR (WHADVP (WRB when)) (S (NP (NP (DT the) (NN structure)) (PP (IN of) (NP (DT a) (NN computation)))) (VP (VBZ is) (VP (VBN fixed) (ADVP (FW a) (FW priori))))))))))))) (. .))
(S (NP (DT That)) (VP (VBZ makes) (S (NP (PRP it)) (ADJP (JJ possible) (S (VP (TO to) (VP (VB perform) (NP (NP (JJ certain) (NNS kinds)) (PP (IN of) (NP (NN static) (NN analysis)))) (PP (IN on) (NP (JJ applicative) (NNS values))))))))) (. .))
(S (NP (PRP We)) (VP (VBP define) (NP (NP (DT a) (NN notion)) (PP (IN of) (NP (JJ free) (NN applicative) (NN functor)))) (, ,) (S (VP (VB prove) (SBAR (SBAR (IN that) (S (NP (PRP it)) (VP (VBZ satisfies) (NP (DT the) (JJ appropriate) (NNS laws))))) (, ,) (CC and) (SBAR (IN that) (S (NP (DT the) (NN construction)) (VP (VBZ is) (VP (VBN left) (NP (NN adjoint)) (PP (IN to) (NP (DT a) (ADJP (JJ suitable) (JJ forgetful)) (NN functor))))))))))) (. .))
(S (NP (PRP We)) (VP (VBP show) (SBAR (WHADVP (WRB how)) (S (NP (JJ free) (NN applicative) (NNS functors)) (VP (MD can) (VP (VB be) (VP (VBN used) (S (VP (TO to) (VP (VB implement) (NP (NP (VBN embedded) (NNS DSLs)) (SBAR (WHNP (WDT which)) (S (VP (MD can) (VP (VB be) (ADVP (RB statically)) (VP (VBN analysed)))))))))))))))) (. .))
