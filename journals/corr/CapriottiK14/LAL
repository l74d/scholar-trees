(S (NP (JJ Applicative) (NNS functors)) (VP (VBP are) (NP (NP (DT a) (NN generalisation)) (PP (IN of) (NP (NNS monads))))) (. .))
(S (NP (DT Both)) (VP (VBP allow) (NP (NP (DT the) (NN expression)) (PP (IN of) (NP (JJ effectful) (NNS computations))) (PP (IN into) (NP (NP (DT an) (ADJP (JJ otherwise) (NN pure)) (NN language)) (, ,) (PP (IN like) (NP (NNP Haskell))))))) (. .))
(S (NP (JJ Applicative) (NNS functors)) (VP (VBP are) (S (VP (TO to) (VP (VB be) (VP (VBN preferred) (PP (TO to) (NP (NNS monads))) (SBAR (WHADVP (WRB when)) (S (NP (NP (DT the) (NN structure)) (PP (IN of) (NP (DT a) (NN computation)))) (VP (VBZ is) (VP (VBN fixed) (ADVP (DT a) (NN priori))))))))))) (. .))
(S (NP (DT That)) (VP (VBZ makes) (S (NP (NP (PRP it))) (ADJP (JJ possible)) (S (VP (TO to) (VP (VB perform) (NP (NP (JJ certain) (NNS kinds)) (PP (IN of) (NP (JJ static) (NN analysis)))) (PP (IN on) (NP (JJ applicative) (NNS values)))))))) (. .))
(S (NP (PRP We)) (VP (VP (VBP define) (NP (NP (DT a) (NN notion)) (PP (IN of) (NP (JJ free) (JJ applicative) (NN functor))))) (, ,) (VP (VBP prove) (SBAR (IN that) (S (NP (PRP it)) (VP (VBZ satisfies) (NP (DT the) (JJ appropriate) (NNS laws)))))) (, ,) (CC and) (SBAR (IN that) (S (NP (DT the) (NN construction)) (VP (VBZ is) (VP (VBN left) (S (ADJP (NN adjoint) (PP (TO to) (NP (DT a) (JJ suitable) (JJ forgetful) (NN functor)))))))))) (. .))
(S (NP (PRP We)) (VP (VBP show) (SBAR (WHADVP (WRB how)) (S (NP (JJ free) (JJ applicative) (NNS functors)) (VP (MD can) (VP (VB be) (VP (VBN used) (S (VP (TO to) (VP (VB implement) (NP (NP (VBN embedded) (NNP DSLs)) (SBAR (WHNP (WDT which)) (S (VP (MD can) (VP (VB be) (VP (ADVP (RB statically)) (VBN analysed)))))))))))))))) (. .))
